/*
 * PanelGrafico.java
 *
 * Created on 13 de Março de 2005, 00:15
 */

package Componentes.Grafico;

import Dados.*;
import Janelas.IFGrafico;
import Sistema.FSys;
import java.awt.Graphics;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Image;



/**
 *
 * @author  Gustavo
 */
public class PanelGrafico extends javax.swing.JPanel {
    
    /** Creates new form PanelGrafico */
    public PanelGrafico( IFGrafico _frame ) {
        this.frame = _frame;
        initComponents();
        setEventos();
        initConfigDefault();
        LD = new Lista();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
    private void initComponents() {

        setLayout(new java.awt.BorderLayout());

    }
    // </editor-fold>//GEN-END:initComponents
    
    public void initConfigDefault() {
        
        Form = new java.text.DecimalFormat("0.000");
        Image image = this.createImage(this.getWidth(), this.getHeight());
        
        /* Inicializa os flags */
        ver_eixoX   = true;
        ver_eixoY   = true;
        ver_NeixoX  = true;
        ver_NeixoY  = true;
        ver_marcas  = true;
        ver_grid    = true;
        ver_escala  = true;
        ver_numeros = true;
        ver_pontos  = true;
        ver_linhas  = true;
        labelX = new String("");
        labelY = new String("");
        
        COR_F = FSys.COR_FUNDO_PADRAO;
        COR_G = FSys.COR_GRID_PADRAO;
        COR_E = FSys.COR_EIXO_PADRAO;
        COR_N = FSys.COR_NUMEROS_PADRAO;
        COR_M = FSys.COR_MARCAS_PADRAO;
        COR_L = FSys.COR_LABEL_PADRAO;
        COR_BORDA = Color.black;
        
        /* Variaveis de controle do grafico */
        P_MOUSE    = new Ponto(0,0);
        ORIGEM     = new Ponto(100,100);
        T_PONTO    =  5;
        tipoPonto  = RECT;
        inc = 1.1f;
        
        espH = 75;
        espV = 50;
        
        nph = 40;   // numero de pixels por unidade horizontal
        npv = 40;   // numero de pixels por unidade vertical
        gh  = 2;    // grid horizontal
        gv  = 2;    // grid vertical
        nh  = 4;    // de quantos em quantos grids aparace os numeros no eixo x
        nv  = 4;    // de quantos em quantos grids aparace os numeros no eixo y
        zh  = 1;    // zoom horizontal
        zv  = 1;    // zzom vertical
    }
    
    
    private void setEventos() {
        this.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                ORIGEM.x = evt.getX();
                ORIGEM.y = evt.getY();
                frame.setLabelPosMouse( new Pontof(0,0) );
                
                repaint();
            }
            public void mousePressed( java.awt.event.MouseEvent e ) {
                P_MOUSE = new Ponto(e.getX(),e.getY());
                BMouse = e.getButton();
            }
        });
        this.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                Ponto p = new Ponto(evt.getX(),evt.getY());
                if( BMouse == 1 ) {
                    ORIGEM.x = ORIGEM.x - (P_MOUSE.x - p.x);
                    ORIGEM.y = ORIGEM.y - (P_MOUSE.y - p.y);
                    P_MOUSE = p;
                    repaint();
                } else {
                    if( BMouse == 3 ) {
                        //repaint();
                        Graphics g = getGraphics();
                        g.setColor(Color.blue);
                        g.drawRect(P_MOUSE.x,P_MOUSE.y,(p.x - P_MOUSE.x),(p.y - P_MOUSE.y));
                    }
                }
            }
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                Ponto p = new Ponto(evt.getX(),evt.getY());
                Pontof m = new Pontof( (float)(p.x - ORIGEM.x)/(nph*zh) , (float)(ORIGEM.y - p.y)/(npv*zv) );
                frame.setLabelPosMouse( m );
            }
        });
    }
    
    /* Funções de Zoom */
    public void setZoom( float h, float v ) {
        if( h > 0 )
            zh = h;
        else zh = 0;
        if( v > 0 )
            zv = v;
        else zv = 0;
        repaint();
    }
    public void MaisZoom() {
        setZoom( zh*inc , zv*inc );
    }
    public void MenosZoom() {
        setZoom( zh/inc , zv/inc );
    }
    public void MaisZoomH() {
        setZoom( zh*inc , zv );
    }
    public void MenosZoomH() {
        setZoom( zh/inc , zv );
    }
    public void MaisZoomV() {
        setZoom( zh , zv*inc );
    }
    public void MenosZoomV() {
        setZoom( zh , zv/inc );
    }
    public void AutoAjuste() {
        double MaiorX = -999999999999D;
        double MenorX = 999999999999D;
        double MaiorY = -999999999999D;
        double MenorY = 999999999999D;
        
        if( LD == null )
            return;
        if( LD.getnNos() <= 0 ) return;
        Dado D;
        Matriz M;
        Vetor V;
        Constante C;
        for( int c = 0; c < LD.getnNos(); c++ ) {
            D = LD.getD( c );
            if( D.eMatriz() ) {
                M = (Matriz)D;
                for( int l = 0; l < M.getnLinhas(); l++ ) {
                    if( MaiorX < M.M[l][0] )
                        MaiorX = M.M[l][0];
                    if( MenorX > M.M[l][0] )
                        MenorX = M.M[l][0];
                    if( MaiorY < M.M[l][1] )
                        MaiorY = M.M[l][1];
                    if( MenorY > M.M[l][1] )
                        MenorY = M.M[l][1];
                }
            } else {
                if( D.eVetor() ) {
                    V = (Vetor)D;
                    for( int lin = 0; lin < V.getTam(); lin++ ) {
                        if( MaiorY < V.getValor(lin) )
                            MaiorY = V.getValor(lin);
                        if( MenorY > V.getValor(lin) )
                            MenorY = V.getValor(lin);
                        if( MenorX > 0 )
                            MenorX = 0;
                        if( MaiorX < V.getTam() )
                            MaiorX = V.getTam();
                    }
                } else { // e constante
                    C = (Constante)D;
                    if( C.getOrientacao() == Constante.HORIZONTAL ) {
                        if( MaiorY < C.getValor() )
                            MaiorY = C.getValor();
                        else {
                            if( MenorY > C.getValor() )
                                MenorY = C.getValor();
                        }
                    } else {  // Orientação vertival
                        if( MaiorX < C.getValor() )
                            MaiorX = C.getValor();
                        else {
                            if( MenorX > C.getValor() )
                                MenorX = C.getValor();
                        }
                    }
                }
            }
        }
        
        Dimension d = this.getSize();
        double div = (MaiorX - MenorX);
        
        if( div == 0 ) {
            repaint();
            return;
        }
        
        if( div < 0 )
            div = div*(-1);
        zh = (float)( (d.width-espH-30) / (div*nph) );
        div = (MaiorY - MenorY);
        
        if( div == 0 ) {
            repaint();
            return;
        }
        if( div < 0 )
            div = div*(-1);
        zv = (float)( (d.height-espV-30) / (div*npv) );
        
        System.out.println("ZV = "+zv+"  ZH = "+zh);
        
        ORIGEM.x = espH + 10 - (int)(MenorX * nph * zh);
        ORIGEM.y = getHeight() - espV + (int)(MenorY * npv * zv) - 10 ;//this.getHeight() + (int)( (MenorY * npv * zv));
        
        repaint();
    }
    
    public void AjusteInicial() {
        zh = zv = 1;
        ORIGEM.x = espH + 10;
        ORIGEM.y = getHeight() - espV - 10 ;
        repaint();
    }
    
    public int AjustaValor( double n ) {
        int inf = (int)n;
        int sup = inf+1;
        double erro1 = sup - n;
        double erro2 = n - inf;
        if(erro1 < erro2) return sup;
        else return inf;
    }
    
    /* Funções de plotagem de dados */
    private void PlotRetaD( PontoD p1, PontoD p2, Graphics g) {
        double x1, y1;
        double x2, y2;
        
        x1 = (ORIGEM.x + ( p1.x * (nph * zh) ));
        y1 = (ORIGEM.y - ( p1.y * (nph * zv) ));
        x1 = AjustaValor(x1);
        y1 = AjustaValor(y1);
        
        x2 = (ORIGEM.x + ( p2.x * (nph * zh) ));
        y2 = (ORIGEM.y - ( p2.y * (nph * zv) ));
        
        x2 = AjustaValor(x2);
        y2 = AjustaValor(y2);
        
        g.drawLine( (int)x1, (int)y1, (int)x2, (int)(y2) );
    }
    private void PlotPonto( double x, double y, Graphics g ) {
        double px, py;
        px = (ORIGEM.x + ( x * (nph * zh) ));
        py = (ORIGEM.y - ( y * (npv * zv) ));
        px = AjustaValor(px);
        py = AjustaValor(py);
        switch (tipoPonto) {
            case RECT:
                g.drawRect( (int)(px - ((int)T_PONTO/2)), (int)(py - ((int)T_PONTO/2)),
                        T_PONTO,T_PONTO );
                break;
            case RECTF:
                g.fillRect( (int)(px - ((int)T_PONTO/2)), (int)(py - ((int)T_PONTO/2)),
                        T_PONTO,T_PONTO );
                break;
            case CIRCLE:
                g.drawOval( (int)(px - ((int)T_PONTO/2)), (int)(py - ((int)T_PONTO/2)),
                        T_PONTO,T_PONTO );
                break;
            case CIRCLEF:
                g.fillOval( (int)(px - ((int)T_PONTO/2)), (int)(py - ((int)T_PONTO/2)),
                        T_PONTO,T_PONTO );
                break;
            case CROSS:
                break;
            case STAR:
                break;
            default:
                g.fillRect( (int)(px - ((int)T_PONTO/2)), (int)(py - ((int)T_PONTO/2)),
                        T_PONTO,T_PONTO );
                break;
        }
    }
    private boolean PlotMatriz( Matriz m , Graphics g ) {
        PontoD p1 = null;
        PontoD p2 = null;
        if( m == null )
            return false;
        if( m.getnColunas() != 2 )
            return false;
        g.setColor( m.getCor() );
        tipoPonto = m.getTipoPonto();
        int t = m.getnLinhas();
        for( int c = 0; c < t; c++ ) {
            if( m.verPontos() ) {
                PlotPonto( m.M[c][0],m.M[c][1], g );
            }
            if( m.verRetas() ) {
                if(p1 == null) {
                    p1 = new PontoD( m.M[c][0],m.M[c][1] );
                    p2 = new PontoD( m.M[c][0],m.M[c][1] );
                } else {
                    p1.x = p2.x;
                    p1.y = p2.y;
                    p2.x = m.M[c][0];
                    p2.y = m.M[c][1];
                }
                PlotRetaD( p1, p2, g);
            }
        }
        //PlotRetaD( new PontoD(2,2), new PontoD(4,5), g);
        return true;
    }
    private boolean PlotVetor( Vetor v, Graphics g ) {
        PontoD p1 = null;
        PontoD p2 = null;
        if( v == null )
            return false;
        int t = v.getTam();
        g.setColor( v.getCor() );
        tipoPonto = v.getTipoPonto();
        for( int c = 0; c < t; c++ ) {
            if( v.verPontos() ) {
                PlotPonto( c, v.getValor(c), g );
            }
            if( v.verRetas() ) {
                if(p1 == null) {
                    p1 = new PontoD( c, v.getValor(c) );
                    p2 = new PontoD( c, v.getValor(c) );
                } else {
                    p1.x = p2.x;
                    p1.y = p2.y;
                    p2.x = c;
                    p2.y = v.getValor(c);
                }
                PlotRetaD( p1, p2, g);
            }
            
        }
        return true;
    }
    private boolean PlotConstante( Constante c, Graphics g ) {
        if( c == null )
            return false;
        double val = c.getValor();
        g.setColor( c.getCor() );
        Dimension d = getSize();
        tipoPonto = c.getTipoPonto();
        
        if( c.getOrientacao() == 1 ) {
            int x = ORIGEM.x + ( (int)(val * (nph * zh) ) );
            g.drawLine( x, 0, x, d.height);   // vertical
        } else {
            int y = ORIGEM.y - ( (int)(val * (nph * zv) ) );
            g.drawLine(0,y,d.width,y);  // horizontal
        }
        return true;
    }
    public boolean Plot( Dado d ) {
        if( LD == null ) {
            return false;
        }
        Dado temp = LD.Procura( d.getName() );
        if( temp != null ) {
            String novoNome = Sistema.FSys.novoNome( LD, d.getName() );
            d.setName( novoNome );
        }
        if ( LD.Insere( d ) ) {
            repaint();
            return true;
        }
        return false;
    }
    public boolean RemovePlot( Dado d ) {
        return RemovePlot( d.getName() );
    }
    public boolean RemovePlot( String d ) {
        if( LD == null )
            return false;
        if ( LD.Remove( d ) ) {
            repaint();
            return true;
        }
        return false;
    }
    private boolean PlotDado( Dado d, Graphics g ) {
        if( d.eConstante() ) {
            PlotConstante( (Constante)d, g );
            return true;
        }
        if( d.eVetor() ) {
            PlotVetor( (Vetor)d, g );
            return true;
        }
        if( d.eMatriz() ) {
            PlotMatriz( (Matriz)d, g );
            return true;
        }
        return false;
    }
    private boolean PlotListaDados( Graphics g ) {
        if( LD == null )
            return false;
        int tam = LD.getnNos();
        Dado d;
        for( int cont = 0; cont < tam; cont++ ) {
            d = LD.getD(cont);
            PlotDado( d ,g );
        }
        return true;
    }
    private void plotEixoX( Graphics g ) {
        int c;
        Dimension d = getSize();
        g.setColor(COR_E);
        g.drawLine(0,ORIGEM.y,d.width,ORIGEM.y);  // horizontal
        for ( c = ORIGEM.x + nph ; c < d.width ; c += nph ) {
            g.drawLine( c , ORIGEM.y - 1 , c , ORIGEM.y + 1 );
        }
        for ( c = ORIGEM.x - nph ; c > 0 ; c -= nph ) {
            g.drawLine( c , ORIGEM.y - 1 , c , ORIGEM.y + 1 );
        }
    }
    private void plotEixoY( Graphics g ) {
        int c;
        Dimension d = getSize();
        g.setColor(COR_E);
        g.drawLine(ORIGEM.x,0,ORIGEM.x,d.height);   // vertical
        g.drawLine(d.width-2,0,d.width-2,d.height);  // linha superior
        g.drawLine(33,0,d.width-2,0);  // linha superior
        for ( c = ORIGEM.y + npv ; c < d.height ; c += npv ) {
            g.drawLine( ORIGEM.x - 1 , c , ORIGEM.x+1 , c );
        }
        for ( c = ORIGEM.y - npv ; c > 0 ; c -= npv ) {
            g.drawLine( ORIGEM.x - 1 , c , ORIGEM.x+1 , c );
        }
    }
    private void plotLegenda( Graphics g ) {
        
    }
    private void plotGrid( Graphics g ) {
        int c;
        int inc;
        Dimension d = getSize();
        g.setColor(COR_G);
        
        inc = (int)(npv/gv); // espacamento do grid vertival
        
        for( c = ORIGEM.x; c > 0 ; c-= inc ) {
            g.drawLine(c,0,c,d.height);   // linhas vertical
        }
        for( c = ORIGEM.x + inc ; c < d.width; c+= inc ) {
            g.drawLine(c,0,c,d.height);   // linhas vertical
        }
        
        inc = (int)(nph/gh); // espacamento do grid horizontal
        
        for( c = ORIGEM.y; c > 0; c-= inc ) {
            g.drawLine(0,c,d.width,c );  // linhas horizontal
        }
        for( c = ORIGEM.y + inc ; c < d.height; c+= inc ) {
            g.drawLine(0,c,d.width,c );  // linhas horizontal
        }
    }
    private void plotNum( Graphics g ) {
        String Num;
        Dimension d = this.getSize();
        VGraf = new Ponto( espH , d.height - espV );
        
        int c;
        if( ver_NeixoY ) {
            g.setColor( COR_F );
            g.fillRect( 0, 0, VGraf.x, getHeight() );
            g.setColor( COR_N );
            
            for ( c = ORIGEM.y ; c < getHeight() ; c += ( nv * npv/gv ) ) {
                g.drawLine( VGraf.x - 2 , c , VGraf.x , c );
                if((ORIGEM.y-c)/(npv*zv) < 99 && (ORIGEM.y-c)/(npv*zv) > -99 ) {
                    Num = Form.format( (ORIGEM.y-c)/(npv*zv) );
                    g.drawString(Num,25,c+5);
                } else {
                    Num = ""+Sistema.FSys.NotacaoCientifica( (ORIGEM.y-c)/(npv*zv) );
                    g.drawString(Num,15,c+5);
                }
                //g.drawString(Num,25,c+5);
            }
            for ( c = ORIGEM.y ; c > 0 ; c -= ( nv * npv/gv ) ) {
                g.drawLine( VGraf.x - 2 , c , VGraf.x , c );
                if((ORIGEM.y-c)/(npv*zv) < 99 && (ORIGEM.y-c)/(npv*zv) > -99 ) {
                    Num = Form.format( (ORIGEM.y-c)/(npv*zv) );
                    g.drawString(Num,25,c+5);
                } else {
                    Num = ""+ Sistema.FSys.NotacaoCientifica( (ORIGEM.y-c)/(npv*zv) );
                    g.drawString(Num,15,c+5);
                }
                //Num = Form.format( (ORIGEM.y-c)/(npv*zv) );
                //g.drawString(Num,25,c+5);
            }
            g.drawLine( VGraf.x , 0 , VGraf.x , getHeight() );
        }
        if( ver_NeixoX ) {
            g.setColor( COR_F );
            g.fillRect( 0, VGraf.y, d.width, d.height );
            g.setColor( COR_N );
            
            for ( c = ORIGEM.x ; c < d.width ; c += ( nh * nph/gh ) ) {
                g.drawLine( c , VGraf.y , c, VGraf.y + 2 );
                if((ORIGEM.y-c)/(npv*zv) < 99 && (ORIGEM.y-c)/(npv*zv) > -99 ) {
                    Num = Form.format( (c-ORIGEM.x)/(nph*zh)  );
                } else {
                    Num = ""+Sistema.FSys.NotacaoCientifica((c-ORIGEM.x)/(nph*zh));
                }
                //Num = Form.format( (c-ORIGEM.x)/(nph*zh)  );
                g.drawString(Num,c-8,VGraf.y+15);
            }
            for ( c = ORIGEM.x ; c > 0 ; c -= ( nh * nph/gh ) ) {
                g.drawLine( c , VGraf.y , c, VGraf.y + 2 );
                if((ORIGEM.y-c)/(npv*zv) < 99 && (ORIGEM.y-c)/(npv*zv) > -99 ) {
                    Num = Form.format( (c-ORIGEM.x)/(nph*zh)  );
                } else {
                    Num = ""+ Sistema.FSys.NotacaoCientifica((c-ORIGEM.x)/(nph*zh));
                }
                //Num = Form.format( (c-ORIGEM.x)/(nph*zh) );
                g.drawString(Num,c-8,VGraf.y+15);
            }
            g.drawLine( 0 , VGraf.y , d.width , VGraf.y );
        }
    }
    private void plotLabelX( Graphics g ) {
        Dimension d = this.getSize();
/*        Graphics2D g2d = (Graphics2D)g;
        AffineTransform at = new AffineTransform();
 
        at.setToRotation(Math.PI*2.0, d.width/2 ,d.height-10);
        g2d.setTransform(at);*/
        g.drawString(labelX, d.width/2 , d.height-10);
    }
    private void plotLabelY( Graphics g ) {
        Dimension d = this.getSize();
        //Graphics2D g2d = (Graphics2D)g;
        //AffineTransform at = new AffineTransform();
        /*at.setToTranslation( 0, 0 );
        at.rotate( -Math.PI/2 );
         
         **/
        //at.setToRotation(-Math.PI/2, 10, 100 );
        g.drawString(labelY, 10 , d.height/2);
        //at.setToRotation( Math.PI/2, 10, 100 );
        //at.rotate( Math.PI/2 );
/*
 
        at.setToRotation(-Math.PI/2.0,ORIGEM.x,ORIGEM.y);
        g2d.setTransform(at);
        g.drawString(labelY, 15 , d.height/2);
        at.setToRotation(Math.PI/2.0, ORIGEM.y,ORIGEM.x);
 */
    }
    private void plotBorda( Graphics g ) {
        Dimension d = getSize();
        g.setColor( COR_BORDA );
        g.drawRect(0,0, d.width,d.height);
    }
    
    public void paint( Graphics g ) {
        Dimension d = this.getSize();
        g.setColor(COR_F);
        //g.clipRect(0,0,d.width,d.height);
        g.fillRect(0,0,d.width,d.height);
        
        if( ver_grid ) plotGrid( g );
        if( ver_eixoX ) plotEixoX( g );
        if( ver_eixoY ) plotEixoY( g );
        if( LD.getnNos() > 0 ) PlotListaDados( g );
        if( ver_numeros ) plotNum( g );
        if( ver_labelY ) plotLabelY( g );
        if( ver_labelX ) plotLabelX( g );
        if( ver_legenda ) plotLegenda( g );
        
//        g.drawString("width: "+d.width+" height: "+d.height,300,200);
        if( ver_NeixoX && ver_NeixoY ) apagaCanto(g);
        plotBorda(g);
    }
    
    public Ponto getOrigem() {
        return ORIGEM;
    }
    public float getZH() {
        return zh;
    }
    public float getZV() {
        return zv;
    }
    
    private void apagaCanto( Graphics g ){
        Dimension d = getSize();
        g.setColor( COR_F );
        g.fillRect(0, d.height-espV, espH+1, espV-1 );
    }
    
    private void plotLabels( Graphics g ) {
        if( ver_eixoX ) plotLabelX( g );
        if( ver_eixoY ) plotLabelY( g);
    }
    
    public Lista getListaDados() {
        return this.LD;
    }
    public Color getCorFundo(){
        return COR_F;
    }
    public Color getCorGrid(){
        return COR_G;
    }
    
    /* Configurações do gráfico */
    public void setVerEixoX( boolean b ) {
        this.ver_eixoX = b;
        repaint();
    }
    public void setVerEixoY( boolean b ) {
        this.ver_eixoY = b;
        repaint();
    }
    public void setVerLabelX( boolean b ) {
        ver_labelX = b;
        repaint();
    }
    public void setVerLabelY( boolean b ) {
        ver_labelY = b;
        repaint();
    }
    public void setVerLegenda( boolean b ) {
        ver_legenda = b;
        repaint();
    }
    public void setNameEixoX( String x ) {
        labelX = x;
    }
    public void setNameEixoY( String y ) {
        labelY = y;
    }
    public void setVerNumX( boolean b ) {
        ver_NeixoX = b;
        repaint();
    }
    public void setVerNumY( boolean b ) {
        ver_NeixoY = b;
        repaint();
    }
    public void setVerGrid( boolean b ) {
        ver_grid = b;
        repaint();
    }
    
    public void setCorFundo( Color c ) {
        COR_F = c;
        repaint();
    }
    public void setCorGrid( Color c ) {
        COR_G = c;
        repaint();
    }
    public void setCorComponente( String nome, Color c ) {
        Dado d = LD.Procura( nome );
        d.setCor(c);
        repaint();
    }
    public void setTipoPontoComponente( String nome, int tipo ) {
        Dado d = LD.Procura( nome );
        d.setTipoPonto( tipo );
        repaint();
    }
    public void setVerLinhasComponente( String nome, boolean b ) {
        Dado d = LD.Procura( nome );
        d.setVerRetas( b);
        repaint();
    }
    public void setVerPontosComponente( String nome, boolean b ) {
        Dado d = LD.Procura( nome );
        d.setVerPontos( b);
        repaint();
    }
    public void setContX( int x ) {
        nh = x;
        repaint();
    }
    public void setContY( int y ) {
        nv = y;
        repaint();
    }

    public Color getCorComponente( String nome ) {
        return LD.Procura(nome).getCor();
    }
    public int getTipoPontoComponete( String nome ) {
        return LD.Procura(nome).getTipoPonto();
    }
    public boolean verRetasComponente( String nome ) {
        return LD.Procura(nome).verRetas();
    }
    public boolean verPontosComponente( String nome ) {
        return LD.Procura(nome).verPontos();
    }

    public void removeEixoX() {
        ver_eixoX = false;
        ver_labelX = false;
        repaint();
    }
    public void removeEixoY() {
        ver_eixoY = false;
        ver_labelY = false;
        repaint();
    }
    public void exibirLegenda() {
        ver_legenda = true;
        repaint();
    }
    public void removerLegenda() {
        ver_legenda = false;
        repaint();
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    private Lista LD;
    private String labelX;
    private String labelY;
    
    private boolean ver_eixoX;
    private boolean ver_eixoY;
    private boolean ver_NeixoX;
    private boolean ver_NeixoY;
    private boolean ver_labelX;
    private boolean ver_labelY;
    private boolean ver_legenda;
    
    private boolean ver_marcas;
    private boolean ver_grid;
    private boolean ver_escala;
    private boolean ver_numeros;
    private boolean ver_pontos;
    private boolean ver_linhas;
    
    /* Variaveis da classe */
    private Color  COR_F;    // Cor fundo
    private Color  COR_G;    // Cor grid
    private Color  COR_E;    // Cor eixos
    private Color  COR_N;    // Cor numeros dos eixos
    private Color  COR_M;    // Cor das marcacoes nos eixos
    private Color  COR_BORDA;// Cor da Borda do gráfico
    private Color  COR_L;    // Cor dos labels
    
    /* Variaveis de controle do grafico */
    private int BMouse;
    private Ponto ORIGEM;       // Armazena a origem do grafico
    private Ponto P_MOUSE;      // Armazena o ponto em que o mouse foi clicado
    private float inc;          // Incremento do Zoom
    private int   T_PONTO;      // Tamanho do ponto
    private int   tipoPonto;    // Tipo do ponto a ser plotado
    
    private final int RECT    = 0;
    private final int RECTF   = 1;
    private final int CIRCLE  = 2;
    private final int CIRCLEF = 3;
    private final int CROSS   = 4;
    private final int MINUS   = 5;
    private final int STAR    = 6;
    
    private int espH;
    private int espV;
    
    private Ponto VGraf;
    
    private java.text.DecimalFormat Form;
    
    private int nph;   // numero de pixels por unidade horizontal
    private int npv;   // numero de pixels por unidade vertical
    private int gh;    // grid horizontal: numero de divisoes por marca de nph
    private int gv;    // grid vertical: numero de divisoes por marca de npv
    private int nv;    // de quantos em quantos grides vertivais aparece um numero no eixo Y
    private int nh;    // de quantos em quantos grides horizontais aparece um numero no eixo X
    private float zh;  // zoom horizontal
    private float zv;  // zzom vertical
    
    private IFGrafico frame;
}